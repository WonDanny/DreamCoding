Danny's Library

[일간 업무 보고]221129_원승대


1. 객체 배열 정렬하기
	- 오름차순
		array.sort((a, b) => {
			return a.name - b.name
		})

	- 내림차순
		array.sort((a, b) => {
			return b.name - a.name
		})



2. 숫자를 분/초로 Convert 함수
	const convertHMS = (duration) => {
		const sec = parseInt(duration, 10);
		let minutes = Math.floor(sec / 60);
		let seconds = sec % 60;

		if(minutes < 10) {
			minutes = '0' + minutes;
		};

		if(seconds < 10) {
			seconds = '0' + seconds;
		}

		return minutes + ":" + seconds;
	};


3. 소수점 두자리수 까지 구하기
	Math.round((12.1212323)*100)/100       // 12.12 두자리
	Math.round((12.1212323)*1000)/1000     //12.121 세자리
	Math.round((timestamp/1000/60)*100)/100

4. 쿼리
	//CREATE문
	//참고1. AUTO_INCREMENT는 PRIMARY KEY에 할당가능하고 PRIMARY KEY가 한개일때만 가능
	//참고2. mysql에서 INT는 특별한 상황이 아니면 default로 INT(11)임
	//참고3. PRIMARY KEY를 여러개 선언할때는 아래와 같이 PRIMARYKEY(QUESTION_IDX, QUIZ_IDX) 로

	CREATE TABLE t_quiz_info
	(
		QUESTION_IDX      INT            NOT NULL     AUTO_INCREMENT  	 COMMENT '문제 넘버',
		QUIZ_IDX          INT            NOT NULL                        COMMENT '퀴즈 넘버',
		QUESTION_TITLE    VARCHAR(30)    NOT NULL                        COMMENT '문제의 제목',
		QUESTION          VARCHAR(200)                                   COMMENT '문제',
		EXAMPLE1    	  VARCHAR(50) 								     COMMENT '보기1',
		EXAMPLE2    	  VARCHAR(50) 								 	 COMMENT '보기2',
		EXAMPLE3    	  VARCHAR(50) 								 	 COMMENT '보기3',
		EXAMPLE4    	  VARCHAR(50) 								 	 COMMENT '보기4',
		EXAMPLE5    	  VARCHAR(50) 								 	 COMMENT '보기5',
		ANSWER      	  VARCHAR(50) 								 	 COMMENT '답안',
		VOD_ID      	  VARCHAR(100)                                   COMMENT '유튜브아이디',
		COMMENT     	  text                                           COMMENT '코치 팁',
		REG_ID     		  INT                                            COMMENT '등록자 고유번호',
		REG_DATE          DATETIME                    DEFAULT NOW()      COMMENT '등록일',
		MOD_ID            INT                                            COMMENT '수정자 고유번호',
		MOD_DATE          DATETIME                    DEFAULT NOW()      COMMENT '수정일',
		PRIMARY KEY (QUESTION_IDX)
	);

	//ALTER문
		1. AUTO_INCREMENT
		ALTER TABLE t_quiz AUTO_INCREMENT = 1;

		2. 컬럼 추가
		ALTER TABLE t_quiz ADD STATUS VARCHAR(1) DEFUALT 'N' AFTER QUIZ_TITLE 

		3. 컬럼 삭제
		ALTER TABLE t_quiz DROP STATUS

		4. 컬럼명 변경
		ALTER TABLE t_quiz CHANGE status STATUS 

		5. 컬럼 기본값(default) 입력 & 수정
		ALTER TABLE t_quiz MODIFY VARCHAR(1) DEFAULT 'N' COMMENT '공개비공개상태';
		ALTER TABLE t_quiz MODIFY REG_DATE DATETIME

		6. 테이블 삭제 
		DROP TABLE t_quiz_info; 
		DROP TABLE t_quiz;
		
		7. 레코드 삭제
		DELETE FROM t_match_arrangement
		WHERE MATCH_ID = 'KR_6144110225';

	//DELETE문 
	DELETE FROM t_quiz_info
	WHERE 1=1
	AND QUESTION_IDX = #{questionIdx};
	
5. 객체(Object)
	1. Object.keys() = 해당 오브젝트의 키값만 가져옴
		예제)
		if(spellInfo) {
            const topSpellList = [];
            Object.keys(summary).forEach((id) => {
                if(id.includes('spell')) {
                    spellInfo.spellTotal += summary[id];
                    topSpellList.push({spellId: id, count: summary[id]})
                };
            });
            
            topSpellList.sort((a,b) => {
                return b.count - a.count;
            });

            if ( topSpellList && topSpellList.length > 1) {
                spellInfo.spell1Id = topSpellList[0].spellId.split('-')[1];
                spellInfo.spell1Count = topSpellList[0].count;
                spellInfo.spell2Id = topSpellList[1].spellId.split('-')[1];
                spellInfo.spell2Count = topSpellList[1].count;
            };
        }; // spellInfo

	2. Object.values() = 해당 오브젝트의 벨류값만 가져옴

	3. []를 사용해서 변수를 오브젝트 키값으로 지정할 수 있음
		ex) value: 'danny', idx: 1
		{...state, [value]: idx} --> {danny: 1}

	4. []를 사용해서 오브젝트의 value를 가져올 수 있음
		ex) obj = {name: danny, age: 32}
		console.log(obj[name])   --> danny
		
6. 솔랭 판단
	//예제
    let soloRank = "";

    if(summonerInfo.league){
        for(let i = 0; i < summonerInfo.league.length; i++) {
            if(summonerInfo.league[i].queueType === 'RANKED_SOLO_5x5'){
                soloRank = summonerInfo.league[i].tier;
                break;
            };
        };
    };

7. switch문

	//예제
	switch(runeID) {
        case 5001 :
            return '체력 +15~140 레벨에 비례'
        case 5002 :
            return '방어력 +6'
        case 5003 :
            return '마법저항력 +8'
        case 5005 :
            return '공격속도 +8'
        case 5007 :
            return '스킬가속 +8'
        case 5008 :
            return '적응형능력치 +9'
        default:
            return '세팅값 없음'
    }

    1665468171326  - 1665468163908
8. moment 관련
	1) moment().valueOf() = 현재 시간 타임스템프
		//예제
		if( (moment().valueOf() - (item.sec || 0))/1000 < 15){
	        setDis('disabled');

	        setTimeout(() => {
	          setDis('enabled');

	        }, 15000 - (moment().valueOf() - (item.sec || 0)))
	    };

	2) moment().format('YYYY-MM-DD hh:mm:ss') = 포맷설정해주기

9. indexOf
	* 문자열에서 특정 문자열을 찾고 검색된 문자열이 첫번째로 나타나는 위치의 index를 리턴한다
	* 찾는 문자열이 없을경우는 -1을 리턴

	ex)
		'dannywon'.indexOf(d)       -> 0
		'dannywon'.indexOf(w)       -> 5
		'dannywon'.indexOf(z)       -> -1  //z는 문자열에 없음

	m['answer'].indexOf(index) > -1

 
10. 중복제거 로직
	const noDupSItemList = []; // 중복없는 아이템을 넣을 빈배열 선언
	let sItems = [];	       // 중복이 있을 수있는 아이템을 넣을 빈배열 선언

	startItems.map((m) => {    // sItem.push (중복이 있을 수 있음)
        if(m != '') {
            sItems.push(itemList?.filter((f) => f.ID == m)[0].NAME); 
        }
    });

    for(let i in sItems) {
    	const item = sItems[i];

    }
    for(let i in sItems){
        const item = sItems[i];
        const info = noDupSItemList.filter((f)=>f.name==item)[0];
        if(info){
            info.cnt = info.cnt+1;
        } else {
            noDupSItemList.push({name:item, cnt:1});
        };
    };


11. 리눅스
	1. 명령어
		- cd: 폴더 변경
		- cd ~ : /root로 이동
		- cd - : 이전 폴더로 왔다갔다
		- cd ..: 상위폴더로 이동
		- ls: 현재 위치에 있는 폴더, 파일 리스트 보여줌
		- cp: 폴더, 파일 카피(복사)함
			ex -> cp MgtCraftboxBanner.png /mnt/d/test        ##mnt는 마운트의 약자로 윈도우의 내PC를 보여주는거 같음
			-r 옵션을 넣어주면 디렉토리 하위 파일들도 다같이 복사함
		- which: 설치되어 있는 파일의 경로를 알려줌
		- mkdir : directory(폴더) 생성
		- rm: 디렉토리 삭제
		- lsof -i TCP:[port]                 -> 해당포트 사용중인 프로세스 목록보기
		- ps -ef | grep

	2. 리눅스에서 깃허브 push용 key 만들기
		* 리눅스환경에서 깃허브에 push 하려면 ssh-key 필요함

		- ssh-keygen -t rsa -C "dannywon91@naver.com" ssh 키 생성
		- /root/.ssh/id_rsa.pub => 퍼블릭 키
		- /root/.ssh/id_rsa     => 프라이빗 키
		- 만들고 난 후에 로컬에 있는 ssh-key를 gitkraken 설정/integrations에서 key connect 시켜야함

	3. ssh 터널링
		#  #
		* 터널링 명령어 : ssh -i [경로] -CNf -L [포트]:[ip:port] -p [터널링하는 port]
		ssh -i ./CTGG-V2-20220124.pem -CNf -L 3306:ctgg-v2.cluster-czsq5066hqh5.ap-northeast-2.rds.amazonaws.com:3306 -p 22 ec2-user@13.125.19.168

	4. 파일권한 설정
		chmod 400 CTGG-V2-20220124.pem

	5. wsl2 관련 정보
		*윈도우 환경에서 가상의 linux환경을 사용하게 할 수 있음 Window Serve System Linux
		1. df -h 명령어 실행하면 /mnt/c, /mnt/d 가있는데 이게 host 서버의 c드라이브, d드라이브 이며 이 경로를 통해서 서로 유가능
	
12. 자바스크립트에서 false인 경우
	- undefined,
	- null,
	- NaN
	- ''
	- 0
	- false


13. REACT
	* 리액트는 state(내부상태), props(외부에서 전달된 상태)가 변경될때마다 re-render 된다.
	* 리액트는 virtual dom을 가지고 있어서 virtual dom과 이전의 dom을 비교해서 변경된 부분만 화면에 업데이트 됨.
	* NEXT.JS 에서 react-quill 사용하려면 먼저 dynamic from 'next/dynamic' 을 import 한 후에 
		- const QuillWrapper = dynamic(() => import ('react-quill'), {
		     ssr: false,
		     loading: () => <p>loading ...</p>
		  });


14. 16:9 계산법
	- (가로길이 / 16) * 9 


15. serverless(서버리스)
	* 서버리스는 서버가 없는 백엔드 라는 뜻이 아닌 우리가 직접 서버를 관리하지 않아 신경 쓸 필요 없는 경우를 뜻함
	* 개발자가 서버리스에 업로드한 함수는(코드) 24시간 내내 돌아가는게 아닌 휴면 상태에 들어간다.
	  그러다가 사용자 요청이 오는 순간 서버리스는 잠들어 있는 함수를 깨우고 요청한 작업을 수행하게 한다. 그리고 다시 잠들게한다
	* AWS 람다같은 경우 백만개의 함수실행을 단돈 20센트밖에안함
		

16. Promise.all
	* 사용법 : 
	await Promise.all([
		example('jacop', 3000),
		example('danny', 2000),
		example('hiz', 1000)
	])

	await Promise.all(users.map((user) => {
		return example('user');
	}));
	

	해당 함수들은 배열의 순서대로 실행되지만 앞에서 실행된 함수의 결과를 기다리지 않고 다음의 함수가 실행된다. 그리고 마지막으로 완료되는 함수까지 기다리다가 값을 반환한다. 이때 반환순서는 실행 순서와 동일하게 준다(완료 순서가 아니다). 
	-> const [res1, res2, res3] = await Promise.all([example('jacop', 3000), example('danny', 2000), example('hiz', 1000)]); 
	이런식으로 변수 할당 가능하다



17. http 상태코드 정리
	. 404: not found (페이지를 찾을 수 없습니다.)
		- 서버에 해당 url로 요청이 들어왔을 때 해당 페이지를 찾을 수 없을 때.

	. 503: service Unavailable (서비스 할 수 없음)
		- 서버가 너무 바쁘거나 유지 관리가 수행 중일 때.




18. next.js
	1. _app.tsx
		- 서버로 요청이 들어왔을때 가장 먼저 실행되는 컴포넌트이며, 페이지에 적용할 공통 레이아웃의 역할을 한다
		- 로직, 전역 스타일 등 컴포넌트에 공통 데이터를 다룬다.
		- 핵심은 모든 페이지에서 공통으로 사용함

	2. _document.tsx
		- _app 다음에 실행되며, 공통적으로 활용할 <head> (Ex. 메타 태그)나 <body> 태그 안에 들어갈 내용들을 커스텀 할때 활용한다
		- 폰트 임포트, charset, 웹 접근성 관련 태그 설정등을 주로 다룬다
		- _document는 언제나 서버에서 실행되므로 브라우저 api 또는 이벤트 핸들러가 포함된 코드는 실행되지 않는다
		  onClick같은 이벤트 핸들러는 작동하지 않음
		  
		- 또한 <Main> 부분을 제외한 부분은 브라우저에서 실행되지 않으므로 이곳에 비즈니스 로직을 추가하면 안된다.
		- 공통적으로 적용할 HTML 마크업을 중심으로 다룬다


	3. NextJs는 일반적인 ReactJs 앱이 아닌 서버사이드 랜더링을 위한 리액트 프레임웤이라 public 폴더에 index.html파일이 없음



19. 메타태그(meta tag)
	1. 정의
		* 메타 데이터란?
			- 해당 데이터에 대한 정보를 제공
			- 어떤 목적을 가지고 만들어진 데이터, 여기서 어떤 목적이란 주로 웹페이지에 대한 정보를 말함(사이트 설명, 키워드 등등)
			- 사이트의 제목, 설명, 이미지 등 포털사이트 api 로봇이 크롤링할때 우기가 지정해놓은 사이트 설명을 긁어갈 수있는 이정표 역할

		- 메타 태그는 페이지의 콘텐츠를 설명하는 텍스트 스니펫
		- 페이지가 무엇을 설명하는지 검색엔진에게 알려주는 아주 중요한 컨텐츠
		- 메타 태그는 일반적으로 페이지의 <head>에 있는 HTML에만 존재하므로 소스코드에서 확인이 가능
		- <meta> 형태의 태그
		- 문서 그 자체를 설명하는 태그를 메타 태그라 함
		- 메타태그는 html문서가 어떤 내용을 담고 있고 그 문서의 핵심 키워드는 무엇이며, 누가 만들었는지, 문자세트(언어설정)는 어떤 것을 사용
		  하는지등의 정보를 담고 있는 태그
		- 구글, 네이버 등과 같은 검색엔진 사이트는 검색엔진 못을통해 이러한 메타 태그를 수집하여 사용자에게 필요한 정보를 제공함

		요약: 메타태그란 HTML 문서 내에 메타데이터를 제공하는 역할
	2. open graph (og tag)
		- 링크의 미리보기 화면의 실체를 구성하는 메타 데이터의 새로운 표기 방법
			-> 카톡에서 mgt.gg 보내면 나오는 미리보기
			
		주로 사용하는 요소(element)
		* og:image
			태그예시 : <meta property="og:image" content="./example.jpg">
			설명 : url링크를 올렸을 때 카카오톡 베북 네이버 등 크롤러가 url을 미리 들어가 정보를 수집할 경우 메타데이터에 오픈그래프로 지정되어
			       있는 이미지를 메인 이미지로 표시해줌

		* og:title
			태그예시 : <meta property="og:title" content="Kodot TEAM">
			설명 : url링크를 올렸을 때 카카오톡 베북 네이버 등 크롤러가 url을 미리 들어가 정보를 수집할 경우 메타데이터에 오픈그래프로 지정되어
			       있는 이미지를 title정보를 긁어와 표시
			       (지정되어있는 <title>태그 내용보다 우선적으로 표시함)

		* og:description
			태그예시 : <meta property="og:description" content="코닷(Kodot)은 제 4차산업혁명 · · ·">
			설명 : URL 링크를 올렸을 때, 카카오톡, 페이스북, 네이버 등등 크롤러가 URL을 미리 들어가 정보를 수집할 경우
					메타데이터에 오픈그래프로 지정되어 있는 description 정보를 긁어와 표시합니다.
					(지정되어 있는 <description>요소의 내용보다 우선적으로 표시하게 됩니다.)

 


20. 데이터를 파일로 만들기
	- yarn add fs
	- fs.appendFileSync(`경로`, JSON.stringify(데이터));
		-> 해당 경로에 파일이 있으면 기존 데이터에 append해서 데이터 write해줌 파일없으면 만들어서 write




